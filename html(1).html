<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>寻找童年的我们・拼图大挑战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        
        .header {
            text-align: center;
            margin: 20px 0 30px;
            width: 100%;
            max-width: 800px;
        }
        
        h1 {
            font-size: 2.8rem;
            color: #4a69bd;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            background: linear-gradient(to right, #4a69bd, #6a89cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .timer-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            font-size: 1.2rem;
            color: #4a69bd;
            font-weight: bold;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            width: 100%;
            max-width: 800px;
        }
        
        .puzzle-area {
            position: relative;
            width: 600px;
            height: 400px;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            overflow: hidden;
            border: 2px dashed #e0e0e0;
        }
        
        .puzzle-piece {
            position: absolute;
            cursor: grab;
            transition: transform 0.2s ease, z-index 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border-radius: 8px;
            z-index: 10;
        }
        
        .puzzle-piece.dragging {
            cursor: grabbing;
            z-index: 100 !important;
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }
        
        .puzzle-piece.correct {
            cursor: default;
            z-index: 1 !important;
            box-shadow: none;
            opacity: 0.9;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        
        button {
            padding: 12px 25px;
            font-size: 1.1rem;
            background: linear-gradient(to right, #4a69bd, #6a89cc);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        button:active {
            transform: translateY(1px);
        }

        .completion-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .completion-message.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .completion-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 90%;
            width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .completion-content h2 {
            font-size: 2.5rem;
            color: #4a69bd;
            margin-bottom: 20px;
        }
        
        .completion-time {
            font-size: 1.8rem;
            color: #e74c3c;
            margin: 20px 0;
            font-weight: bold;
        }
        
        @media (max-width: 650px) {
            .puzzle-area {
                width: 95vw;
                height: 60vw;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>寻找童年的我们・拼图大挑战</h1>
        <div class="timer-container">
            <div>游戏时间: <span id="timer">00:00</span></div>
            <div>完成时间: <span id="completion-time">未完成</span></div>
        </div>
    </div>
    
    <div class="game-container">
        <div class="puzzle-area" id="puzzleArea"></div>
        
        <div class="controls">
            <button id="resetBtn">开始</button>
        </div>
    </div>

    <div class="completion-message" id="completionMessage">
        <div class="completion-content">
            <h2>恭喜完成拼图！</h2>
            <p>你成功找回了童年的记忆！</p>
            <div class="completion-time" id="finalTime"></div>
            <button id="playAgainBtn">再玩一次</button>
        </div>
    </div>

    <script>
        // 游戏配置
        const ROWS = 3;
        const COLS = 4;
        const TOTAL_PIECES = ROWS * COLS;
        const SNAP_DISTANCE = 30; // 吸附距离
        
        // 游戏状态
        let gameStarted = false;
        let startTime = null;
        let timerInterval = null;
        let pieces = [];
        let completedPieces = 0;
        let puzzleImage = null;
        
        // DOM元素
        const puzzleArea = document.getElementById('puzzleArea');
        const timerElement = document.getElementById('timer');
        const completionTimeElement = document.getElementById('completion-time');
        const resetBtn = document.getElementById('resetBtn');
        const completionMessage = document.getElementById('completionMessage');
        const finalTimeElement = document.getElementById('finalTime');
        const playAgainBtn = document.getElementById('playAgainBtn');
        
        // 初始化游戏
        function initGame() {
            // 清除之前的拼图
            puzzleArea.innerHTML = '';
            pieces = [];
            completedPieces = 0;
            gameStarted = false;
            clearInterval(timerInterval);
            timerElement.textContent = '00:00';
            
            // 创建背景图像（作为参考）
            puzzleImage = new Image();
            // 使用一个可靠的测试图片URL
            puzzleImage.src = 'https://tongyi-main.oss-accelerate.aliyuncs.com/upload/20251212/14905e1edb326035f81495971622a8bb/5b32de40fdd64c4d9565330ba7ab06fb/image.png?Expires=1828574136&OSSAccessKeyId=LTAI5tL97mBYzVcjkG1cUyin&Signature=Php6OZKFLPO3tg3nIWv8gXp4H78%3D';
            
            // 添加错误处理
            puzzleImage.onerror = function() {
                console.error('图片加载失败，使用默认图片');
                // 使用一个备用图片URL
                puzzleImage.src = 'https://picsum.photos/600/400?random=123';
            };
            
            puzzleImage.onload = () => {
                createPuzzlePieces();
                startTimer();
            };
        }
        
        // 创建拼图碎片
        function createPuzzlePieces() {
            const pieceWidth = puzzleArea.clientWidth / COLS;
            const pieceHeight = puzzleArea.clientHeight / ROWS;
            
            // 创建所有碎片
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = document.createElement('div');
                    piece.className = 'puzzle-piece';
                    piece.dataset.row = row;
                    piece.dataset.col = col;
                    
                    // 设置碎片大小
                    piece.style.width = `${pieceWidth}px`;
                    piece.style.height = `${pieceHeight}px`;
                    
                    // 计算碎片在原始图片中的位置
                    const bgPosX = -col * pieceWidth;
                    const bgPosY = -row * pieceHeight;
                    
                    // 应用背景图像
                    piece.style.backgroundImage = `url(${puzzleImage.src})`;
                    piece.style.backgroundSize = `${puzzleArea.clientWidth}px ${puzzleArea.clientHeight}px`;
                    piece.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
                    
                    // 添加随机旋转（创建不规则效果）
                    const rotation = Math.random() * 20 - 10; // -10° 到 10°
                    piece.style.transform = `rotate(${rotation}deg)`;
                    
                    // 设置初始位置（居中区域随机分布）
                    const centerX = puzzleArea.clientWidth / 2;
                    const centerY = puzzleArea.clientHeight / 2;
                    const offsetX = (Math.random() - 0.5) * 300;
                    const offsetY = (Math.random() - 0.5) * 200;
                    
                    piece.style.left = `${centerX + offsetX - pieceWidth/2}px`;
                    piece.style.top = `${centerY + offsetY - pieceHeight/2}px`;
                    
                    // 添加拖拽事件
                    addDragEvents(piece);
                    
                    puzzleArea.appendChild(piece);
                    pieces.push(piece);
                }
            }
        }
        
        // 添加拖拽事件
        function addDragEvents(piece) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            piece.addEventListener('mousedown', startDrag);
            piece.addEventListener('touchstart', startDrag);
            
            function startDrag(e) {
                if (piece.classList.contains('correct')) return;
                
                isDragging = true;
                piece.classList.add('dragging');
                
                const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
                const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
                
                startX = clientX;
                startY = clientY;
                initialX = parseFloat(piece.style.left) || 0;
                initialY = parseFloat(piece.style.top) || 0;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag, { passive: false });
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchend', endDrag);
                
                e.preventDefault();
            }
            
            function drag(e) {
                if (!isDragging) return;
                
                const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
                
                const deltaX = clientX - startX;
                const deltaY = clientY - startY;
                
                piece.style.left = `${initialX + deltaX}px`;
                piece.style.top = `${initialY + deltaY}px`;
            }
            
            function endDrag() {
                if (!isDragging) return;
                
                isDragging = false;
                piece.classList.remove('dragging');
                
                // 检查是否放置在正确位置
                checkPlacement(piece);
                
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchend', endDrag);
            }
        }
        
        // 检查碎片是否放置在正确位置
        function checkPlacement(piece) {
            const row = parseInt(piece.dataset.row);
            const col = parseInt(piece.dataset.col);
            const pieceWidth = puzzleArea.clientWidth / COLS;
            const pieceHeight = puzzleArea.clientHeight / ROWS;
            
            // 计算正确位置
            const correctX = col * pieceWidth;
            const correctY = row * pieceHeight;
            
            // 获取当前碎片位置
            const currentX = parseFloat(piece.style.left) || 0;
            const currentY = parseFloat(piece.style.top) || 0;
            
            // 计算距离正确位置的距离
            const distance = Math.sqrt(
                Math.pow(currentX - correctX, 2) + 
                Math.pow(currentY - correctY, 2)
            );
            
            // 如果足够接近，自动吸附到正确位置
            if (distance <= SNAP_DISTANCE) {
                piece.style.left = `${correctX}px`;
                piece.style.top = `${correctY}px`;
                piece.style.transform = 'rotate(0deg)'; // 移除旋转
                piece.classList.add('correct');
                completedPieces++;
                
                // 检查是否完成
                if (completedPieces === TOTAL_PIECES) {
                    completeGame();
                }
            }
        }
        
        // 开始计时器
        function startTimer() {
            if (gameStarted) return;
            gameStarted = true;
            startTime = Date.now();
            
            timerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        
        // 完成游戏
        function completeGame() {
            clearInterval(timerInterval);
            const elapsed = Date.now() - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // 保存完成时间到本地存储
            localStorage.setItem('puzzleCompletionTime', timeString);
            completionTimeElement.textContent = timeString;
            
            // 显示完成消息
            finalTimeElement.textContent = `用时: ${timeString}`;
            completionMessage.classList.add('show');
        }
        
        // 从本地存储加载完成时间
        function loadCompletionTime() {
            const savedTime = localStorage.getItem('puzzleCompletionTime');
            if (savedTime) {
                completionTimeElement.textContent = savedTime;
            }
        }
        
        // 事件监听器
        resetBtn.addEventListener('click', initGame);
        playAgainBtn.addEventListener('click', () => {
            completionMessage.classList.remove('show');
            initGame();
        });
        
        // 初始化游戏
        window.addEventListener('load', () => {
            loadCompletionTime();
            initGame();
        });
        
        // 响应窗口大小变化
        window.addEventListener('resize', () => {
            if (pieces.length > 0) {
                // 重新开始游戏以适应新尺寸
                initGame();
            }
        });
    </script>
</body>
</html>