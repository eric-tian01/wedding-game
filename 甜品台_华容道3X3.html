<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>婚礼请柬拼图游戏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "PingFang SC", "Microsoft YaHei", sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }
    .wrap {
      width: min(520px, 96vw);
      margin: 16px auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    h1 {
      margin: 0;
      font-size: 22px;
      text-align: center;
    }
    .subtitle {
      text-align: center;
      font-size: 13px;
      opacity: 0.75;
      margin-bottom: 4px;
    }
    .panel {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
      box-sizing: border-box;
    }
    .info {
      font-size: 12px;
      opacity: 0.8;
      margin-bottom: 8px;
    }
    .puzzle-container {
      width: 100%;
      aspect-ratio: 1 / 1;
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      background: #020617;
      border: 2px solid rgba(148, 163, 184, 0.4);
      touch-action: manipulation;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .status-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      margin-top: 6px;
    }
    .big-time {
      font-size: 18px;
      font-weight: 600;
    }
    .hint {
      font-size: 12px;
      opacity: 0.8;
      text-align: center;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>婚礼请柬拼图</h1>
    <div class="subtitle">拼完请柬，记录用时，最短者获胜</div>

    <div class="panel">
      <div class="info">
        说明：页面加载后拼图会<strong>自动打乱并开始计时</strong>。<br/>
        参与者只能通过点击/触屏移动方块来拼图，无法再次打乱设置。
      </div>

      <div class="puzzle-container">
        <canvas id="puzzleCanvas"></canvas>
      </div>

      <div class="status-row">
        <div>时间：<span id="time" class="big-time">0.0</span> 秒</div>
        <div>步数：<span id="moves">0</span></div>
      </div>
      <div class="hint">
        操作：点击 / 触屏点按与空白格相邻的方块，即可滑动该方块。
      </div>
    </div>
  </div>

  <script>
    /*************** 可调参数（你作为发起人可以改） ***************/
    // 1. 图片路径：请把你的请柬图文件放在同一目录下并命名为 wedding.png
    //    如果你想用别的名字，改这一行即可：
    const IMAGE_SRC = "wedding.png";

    // 2. 网格大小：4 表示 4×4；如果想简单一点，改成 3（3×3）。
    const GRID_SIZE = 3;
    /****************************************************************/

    const canvas = document.getElementById("puzzleCanvas");
    const ctx = canvas.getContext("2d");
    const timeEl = document.getElementById("time");
    const movesEl = document.getElementById("moves");

    let img = new Image();
    img.src = IMAGE_SRC;

    // 用于切图的方形离屏画布，保证整张图片被缩放后完整放入
    const imgCanvas = document.createElement("canvas");
    const IMG_CANVAS_SIZE = 800; // 内部处理用，不影响外观
    imgCanvas.width = IMG_CANVAS_SIZE;
    imgCanvas.height = IMG_CANVAS_SIZE;
    const imgCtx = imgCanvas.getContext("2d");

    let gridSize = GRID_SIZE;
    let board = [];   // 长度 N^2，值 0..N^2-1（最后一个视为空）
    let emptyIndex = 0;
    let tileSizePx = 0;
    let squareSize = IMG_CANVAS_SIZE;
    let srcX = 0, srcY = 0;
    let moves = 0;
    let running = false;
    let startTime = null;
    let timerId = null;
    let imgProcessed = false;

    function resetTimer() {
      stopTimer();
      timeEl.textContent = "0.0";
    }

    function startTimer() {
      startTime = performance.now();
      if (timerId) cancelAnimationFrame(timerId);

      function tick(now) {
        if (!running) return;
        const elapsed = (now - startTime) / 1000;
        timeEl.textContent = elapsed.toFixed(1);
        timerId = requestAnimationFrame(tick);
      }
      running = true;
      timerId = requestAnimationFrame(tick);
    }

    function stopTimer() {
      if (timerId) {
        cancelAnimationFrame(timerId);
        timerId = null;
      }
    }

    function updateMoves() {
      movesEl.textContent = moves;
    }

    function coordFromIndex(idx) {
      return {
        r: Math.floor(idx / gridSize),
        c: idx % gridSize,
      };
    }

    function indexFromCoord(r, c) {
      return r * gridSize + c;
    }

    function isAdjacentToEmpty(idx) {
      const { r, c } = coordFromIndex(idx);
      const { r: er, c: ec } = coordFromIndex(emptyIndex);
      return Math.abs(r - er) + Math.abs(c - ec) === 1;
    }

    function checkSolved() {
      for (let i = 0; i < board.length; i++) {
        if (board[i] !== i) return false;
      }
      return true;
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!imgProcessed) {
        // 图片还没准备好时的占位
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#9ca3af";
        ctx.font = "14px -apple-system, system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("正在加载图片，请稍候…", canvas.width / 2, canvas.height / 2);
        return;
      }

      const tileSrcSize = squareSize / gridSize;

      for (let i = 0; i < board.length; i++) {
        const tile = board[i];
        if (tile === board.length - 1) continue; // 空白块

        const { r, c } = coordFromIndex(i);
        const dx = c * tileSizePx;
        const dy = r * tileSizePx;

        const tileRow = Math.floor(tile / gridSize);
        const tileCol = tile % gridSize;

        const sx = srcX + tileCol * tileSrcSize;
        const sy = srcY + tileRow * tileSrcSize;

        ctx.drawImage(
          imgCanvas,
          sx, sy, tileSrcSize, tileSrcSize,
          dx, dy, tileSizePx, tileSizePx
        );
      }

      // 网格线
      ctx.strokeStyle = "rgba(15,23,42,0.7)";
      ctx.lineWidth = 1;
      for (let i = 1; i < gridSize; i++) {
        const pos = i * tileSizePx;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(canvas.width, pos);
        ctx.stroke();
      }
    }

    function initBoard() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.width;

      if (!imgProcessed) {
        drawBoard();
        return;
      }

      const total = gridSize * gridSize;
      board = [];
      for (let i = 0; i < total; i++) {
        board.push(i);
      }
      emptyIndex = total - 1;
      moves = 0;
      updateMoves();
      resetTimer();
      running = false;

      tileSizePx = canvas.width / gridSize;
      squareSize = IMG_CANVAS_SIZE;
      srcX = 0;
      srcY = 0;

      drawBoard();
    }

    // 随机做若干合法移动以打乱（保证一定有解）
    function shuffleBoard(times = 200) {
      for (let k = 0; k < times; k++) {
        const neighbors = [];
        const { r, c } = coordFromIndex(emptyIndex);
        const dirs = [
          { dr: -1, dc: 0 },
          { dr: 1, dc: 0 },
          { dr: 0, dc: -1 },
          { dr: 0, dc: 1 },
        ];
        for (const d of dirs) {
          const nr = r + d.dr;
          const nc = c + d.dc;
          if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
            neighbors.push(indexFromCoord(nr, nc));
          }
        }
        const choice = neighbors[Math.floor(Math.random() * neighbors.length)];
        const tmp = board[choice];
        board[choice] = board[emptyIndex];
        board[emptyIndex] = tmp;
        emptyIndex = choice;
      }
      moves = 0;
      updateMoves();
      drawBoard();
    }

    function handlePointer(clientX, clientY) {
      if (!running || !imgProcessed) return;

      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      if (x < 0 || y < 0 || x >= rect.width || y >= rect.height) return;

      const c = Math.floor(x / tileSizePx);
      const r = Math.floor(y / tileSizePx);
      const idx = indexFromCoord(r, c);

      if (!isAdjacentToEmpty(idx)) return;

      const tmp = board[idx];
      board[idx] = board[emptyIndex];
      board[emptyIndex] = tmp;
      emptyIndex = idx;
      moves++;
      updateMoves();
      drawBoard();

      if (checkSolved()) {
        running = false;
        stopTimer();
        const used = parseFloat(timeEl.textContent);
        setTimeout(() => {
          alert(`拼图完成！用时 ${used.toFixed(1)} 秒，步数 ${moves} 步。`);
        }, 150);
      }
    }

    canvas.addEventListener("click", (e) => {
      handlePointer(e.clientX, e.clientY);
    });

    canvas.addEventListener("touchstart", (e) => {
      const t = e.touches[0];
      handlePointer(t.clientX, t.clientY);
    }, { passive: true });

    // 图片加载完成后：
    img.onload = () => {
      // 把整张图等比例缩放到 IMG_CANVAS_SIZE×IMG_CANVAS_SIZE 的正方形中
      const iw = img.width;
      const ih = img.height;
      const scale = Math.min(IMG_CANVAS_SIZE / iw, IMG_CANVAS_SIZE / ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = (IMG_CANVAS_SIZE - dw) / 2;
      const dy = (IMG_CANVAS_SIZE - dh) / 2;

      imgCtx.fillStyle = "#ffffff";
      imgCtx.fillRect(0, 0, IMG_CANVAS_SIZE, IMG_CANVAS_SIZE);
      imgCtx.drawImage(img, 0, 0, iw, ih, dx, dy, dw, dh);

      imgProcessed = true;
      initBoard();
      // 自动打乱并开始计时 —— 参与者没有按钮可以重复打乱
      shuffleBoard(gridSize * gridSize * 8);
      startTimer();
    };

    img.onerror = () => {
      ctx.fillStyle = "#020617";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#f97316";
      ctx.font = "14px -apple-system, system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("图片加载失败，请检查 IMAGE_SRC 路径。", canvas.width / 2, canvas.height / 2);
    };

    // 初始绘制占位，并设置自适应
    window.addEventListener("load", () => {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.width;
      drawBoard();
    });

    window.addEventListener("resize", () => {
      initBoard();
      drawBoard();
    });
  </script>
</body>
</html>
