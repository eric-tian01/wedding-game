<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>你小时候那么可爱，我也想看看</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body{
      margin:0; padding:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","PingFang SC","Microsoft YaHei",sans-serif;
      background:#0f172a; color:#e5e7eb;
      display:flex; justify-content:center; align-items:flex-start;
      min-height:100vh;
    }
    .wrap{
      width:min(700px,96vw);
      margin:16px auto;
      display:flex; flex-direction:column; gap:10px;
    }
    h1{ margin:0; font-size:22px; text-align:center; letter-spacing:.04em; }
    .subtitle{ text-align:center; font-size:13px; opacity:.85; margin-top:4px; margin-bottom:4px; }

    .panel{
      background:radial-gradient(circle at top, rgba(30,64,175,0.35), rgba(15,23,42,0.95));
      border-radius:14px;
      padding:10px 12px 12px;
      box-shadow:0 8px 24px rgba(0,0,0,.6);
      box-sizing:border-box;
    }
    .info{ font-size:12px; opacity:.92; margin-bottom:8px; line-height:1.6; }
    .info strong{ color:#fde68a; font-weight:700; }

    /* 只保留一个正方形框 */
    .puzzle-container{
      width:100%;
      aspect-ratio:1/1;
      position:relative;
      border-radius:14px;
      overflow:hidden;
      background:#020617;
      border:2px solid rgba(148,163,184,.5);
      touch-action:none;
    }
    canvas{ width:100%; height:100%; display:block; }

    .status-row{
      display:flex;
      justify-content:space-between;
      font-size:13px;
      margin-top:8px;
      align-items:baseline;
    }
    .help{
      margin-top:6px;
      font-size:12px;
      opacity:.88;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <h1>你小时候那么可爱，我也想看看</h1>
      <div class="subtitle">大家请帮帮我！</div>
    </div>

    <div class="panel">
      <div class="info">
        说明：页面加载后拼图会自动打乱并开始计时。<br>
        <strong id="gridText"></strong>
      </div>

      <div class="puzzle-container">
        <canvas id="cv"></canvas>
      </div>

      <div class="status-row">
        <div>时间：<span id="t">0.00</span> 秒</div>
        <div>已就位碎片：<span id="done">0</span>/<span id="total">0</span></div>
      </div>

      <!-- 操作/提示 两行 -->
      <div class="help">
        <div>操作：按住碎片拖动到正确位置，接近目标会自动吸附。</div>
        <div>提示：碎片最开始堆叠在同一个框内，慢慢“抽出来”拼即可。</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== 你只需要改这三行 =====
  const ROWS = 4;                         // 行
  const COLS = 4;                         // 列
  const IMAGE_URL = "./assets/images/my_photo_v1.png?v=20251213"; // 图片路径(放 assets)，v=改大可防缓存
  // ============================

  const total = ROWS * COLS;
  document.getElementById("total").textContent = total;
  document.getElementById("gridText").textContent = `本次为 ${ROWS}×${COLS}，共 ${total} 块碎片。`;

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const tEl = document.getElementById("t");
  const doneEl = document.getElementById("done");

  let W=0, H=0, scale=1;
  let img = new Image();
  img.decoding = "async";

  let pieces = []; // {sx,sy,sw,sh, x,y, w,h, tx,ty, placed}
  let dragging = null;
  let dragOffX=0, dragOffY=0;

  let startTime = 0;
  let timer = null;

  function resizeCanvas(){
    const box = cv.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    W = Math.floor(box.width);
    H = Math.floor(box.height);
    cv.width = Math.floor(W * dpr);
    cv.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  function buildPieces(){
    pieces = [];
    const tileW = W / COLS;
    const tileH = H / ROWS;

    // 让图片“填满”正方形 canvas：用 cover 思路
    const imgAR = img.width / img.height;
    const boxAR = W / H;

    let drawW, drawH, offsetX, offsetY;
    if (imgAR > boxAR){
      // 图片更宽，按高铺满，左右裁切
      drawH = img.height;
      drawW = img.height * boxAR;
      offsetX = (img.width - drawW)/2;
      offsetY = 0;
    } else {
      // 图片更高，按宽铺满，上下裁切
      drawW = img.width;
      drawH = img.width / boxAR;
      offsetX = 0;
      offsetY = (img.height - drawH)/2;
    }

    const sw = drawW / COLS;
    const sh = drawH / ROWS;

    // 初始：所有碎片堆叠在框内（中心附近随机抖动，允许重叠）
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const tx = c * tileW;
        const ty = r * tileH;

        const jitter = 18; // 堆叠抖动幅度(像素)
        const x0 = (W - tileW)/2 + (Math.random()*2-1)*jitter;
        const y0 = (H - tileH)/2 + (Math.random()*2-1)*jitter;

        pieces.push({
          sx: offsetX + c*sw,
          sy: offsetY + r*sh,
          sw, sh,
          x: x0, y: y0,
          w: tileW, h: tileH,
          tx, ty,
          placed: false
        });
      }
    }
    // 打乱层级（绘制顺序）
    pieces.sort(() => Math.random() - 0.5);
    doneEl.textContent = "0";
  }

  function draw(){
    if (!W || !H) return;
    ctx.clearRect(0,0,W,H);

    // 背景
    ctx.fillStyle = "#020617";
    ctx.fillRect(0,0,W,H);

    if (!img.complete) {
      ctx.fillStyle = "rgba(229,231,235,.7)";
      ctx.font = "14px system-ui, -apple-system, Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText("正在加载照片，请稍候…", W/2, H/2);
      return;
    }

    // 先画未拖动的，再画拖动的（保证拖动在最上层）
    const list = dragging ? pieces.filter(p=>p!==dragging).concat([dragging]) : pieces;
    for (const p of list){
      ctx.globalAlpha = p.placed ? 0.92 : 1.0;
      ctx.drawImage(img, p.sx,p.sy,p.sw,p.sh, p.x,p.y,p.w,p.h);

      // 轻微边框
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = "#94a3b8";
      ctx.lineWidth = 1;
      ctx.strokeRect(p.x+0.5,p.y+0.5,p.w-1,p.h-1);
      ctx.globalAlpha = 1.0;
    }
  }

  function hitTest(mx,my){
    // 从上往下找（后画的在上面）
    for (let i=pieces.length-1; i>=0; i--){
      const p = pieces[i];
      if (p.placed) continue;
      if (mx>=p.x && mx<=p.x+p.w && my>=p.y && my<=p.y+p.h) return p;
    }
    return null;
  }

  function snapIfClose(p){
    const dx = p.x - p.tx;
    const dy = p.y - p.ty;
    const dist = Math.hypot(dx,dy);
    const thresh = Math.min(p.w,p.h) * 0.18; // 吸附阈值
    if (dist < thresh){
      p.x = p.tx;
      p.y = p.ty;
      p.placed = true;
      updateDone();
      return true;
    }
    return false;
  }

  function updateDone(){
    const done = pieces.filter(p=>p.placed).length;
    doneEl.textContent = String(done);
    if (done === total){
      stopTimer();
    }
  }

  function startTimer(){
    if (timer) return;
    startTime = performance.now();
    timer = setInterval(() => {
      const s = (performance.now() - startTime)/1000;
      tEl.textContent = s.toFixed(2);
    }, 60);
  }
  function stopTimer(){
    if (!timer) return;
    clearInterval(timer);
    timer = null;
  }

  function pointerPos(e){
    const rect = cv.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left),
      y: (e.clientY - rect.top)
    };
  }

  cv.addEventListener("pointerdown", (e) => {
    const {x,y} = pointerPos(e);
    const p = hitTest(x,y);
    if (!p) return;

    startTimer();
    dragging = p;

    // 提到最上层：把它移到数组末尾
    pieces = pieces.filter(q=>q!==p);
    pieces.push(p);

    dragOffX = x - p.x;
    dragOffY = y - p.y;
    cv.setPointerCapture(e.pointerId);
    draw();
  });

  cv.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const {x,y} = pointerPos(e);
    dragging.x = x - dragOffX;
    dragging.y = y - dragOffY;
    draw();
  });

  cv.addEventListener("pointerup", (e) => {
    if (!dragging) return;
    snapIfClose(dragging);
    dragging = null;
    draw();
  });

  window.addEventListener("resize", () => {
    resizeCanvas();
    // 重建碎片（避免尺寸变了坐标错位）
    if (img.complete) {
      buildPieces();
      draw();
    }
  });

  // 加载图片：如果这里失败，你就会一直看到“正在加载照片…”
  img.onload = () => {
    resizeCanvas();
    buildPieces();
    draw();
  };
  img.onerror = () => {
    resizeCanvas();
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "rgba(229,231,235,.85)";
    ctx.font = "14px system-ui, -apple-system, Segoe UI";
    ctx.textAlign = "center";
    ctx.fillText("图片加载失败：请检查 assets/images/my-photo.jpg 路径、大小写、文件名是否正确。", W/2, H/2);
  };
  img.src = IMAGE_URL;

})();
</script>
</body>
</html>

