<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>你小时候那么可爱，我也想看看</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "PingFang SC", "Microsoft YaHei", sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }
    .wrap {
      width: min(700px, 96vw);
      margin: 16px auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    h1 {
      margin: 0;
      font-size: 22px;
      text-align: center;
      letter-spacing: 0.04em;
    }
    .subtitle {
      text-align: center;
      font-size: 13px;
      opacity: 0.8;
      margin-top: 4px;
      margin-bottom: 4px;
    }
    .panel {
      background: radial-gradient(circle at top, rgba(30,64,175,0.35), rgba(15,23,42,0.95));
      border-radius: 14px;
      padding: 10px 12px 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.6);
      box-sizing: border-box;
    }
    .info {
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 8px;
      line-height: 1.5;
    }
    .info strong {
      color: #fde68a;
      font-weight: 600;
    }
    .puzzle-container {
      width: 100%;
      aspect-ratio: 1 / 1;
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      background: #020617;
      border: 2px solid rgba(148, 163, 184, 0.5);
      touch-action: none;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .status-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      margin-top: 6px;
      align-items: baseline;
    }
    .big-time {
      font-size: 18px;
      font-weight: 600;
    }
    .hint {
      font-size: 12px;
      opacity: 0.8;
      text-align: center;
      margin-top: 4px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>你小时候那么可爱，我也想看看</h1>
    <div class="subtitle">请大家帮帮我！</div>

    <div class="panel">
      <div class="info">
        这张童年照片被撕成了 <strong>16 块不规则碎片</strong>。<br/>
        碎片已随机散落在同一个画布里，把它们拖到正确位置即可无缝拼合。<br/>
      </div>

      <div class="puzzle-container">
        <canvas id="puzzleCanvas"></canvas>
      </div>

      <div class="status-row">
        <div>时间：<span id="time" class="big-time">0.00</span> 秒</div>
        <div>已就位碎片：<span id="moves">0</span> / 16</div>
      </div>
      <div class="hint">
        操作：按住碎片拖动到正确位置，会自动吸附。<br/>
        提示：全部完成后会触发“亮起来”的淡出效果。<br/>
      </div>
    </div>
  </div>

  <script>
    /*************** 可调参数 ***************/
    // GitHub Pages 子目录项目建议："/wedding-game/assets/images/my-photo-v1.png"
    const IMAGE_SRC = "./assets/images/my-photo-v1.png";
    const ROWS = 4;
    const COLS = 4;  // 4x4=16
    const EDGE_JAG_FACTOR = 0.18;
    const EDGE_SEGMENTS_PER_ROW = 4;
    const REVEAL_DURATION = 1200;
    /****************************************/

    const canvas = document.getElementById("puzzleCanvas");
    const ctx = canvas.getContext("2d");
    const timeEl = document.getElementById("time");
    const movesEl = document.getElementById("moves");

    const img = new Image();

    // 离屏画布：存放原图（彩色）
    const IMG_CANVAS_SIZE = 800;
    const imgCanvas = document.createElement("canvas");
    imgCanvas.width = IMG_CANVAS_SIZE;
    imgCanvas.height = IMG_CANVAS_SIZE;
    const imgCtx = imgCanvas.getContext("2d");

    let pieces = [];
    let piecesPlaced = 0;

    // 现在只保留一个区域：boardArea（同一画布内）
    let boardArea = null;

    let running = false;
    let startTime = null;
    let timerId = null;

    let currentPiece = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    let imageInitialized = false;

    // 完成后滤镜淡出
    let revealProgress = 0;    // 0 -> 1
    let revealing = false;
    let revealStartTime = null;

    function resetTimer() {
      stopTimer();
      timeEl.textContent = "0.00";
    }

    function startTimer() {
      startTime = performance.now();
      if (timerId) cancelAnimationFrame(timerId);

      running = true;
      function tick(now) {
        if (!running) return;
        const elapsed = (now - startTime) / 1000;
        timeEl.textContent = elapsed.toFixed(2);
        timerId = requestAnimationFrame(tick);
      }
      timerId = requestAnimationFrame(tick);
    }

    function stopTimer() {
      if (timerId) {
        cancelAnimationFrame(timerId);
        timerId = null;
      }
    }

    function updateMoves() {
      movesEl.textContent = piecesPlaced;
    }

    function layoutCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.width;

      const w = canvas.width;
      const h = canvas.height;

      // 单一画布区域：留一点边距更好看
      const pad = Math.round(w * 0.05);
      boardArea = {
        x: pad,
        y: pad,
        width: w - 2 * pad,
        height: h - 2 * pad,
      };
    }

    function clearCanvas() {
      ctx.fillStyle = "#020617";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawAreas() {
      // 只画一个方框（目标画布）
      ctx.strokeStyle = "rgba(248,250,252,0.9)";
      ctx.lineWidth = 2;
      ctx.strokeRect(boardArea.x, boardArea.y, boardArea.width, boardArea.height);

      ctx.font = "11px -apple-system, system-ui, sans-serif";
      ctx.fillStyle = "rgba(148,163,184,0.9)";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("在这个方框里把碎片拼好", boardArea.x + boardArea.width / 2, boardArea.y + 4);
    }

    // 生成竖直切割线：从上到下的连续曲线（在 boardArea 内）
    function generateVerticalCurves() {
      const curves = [];
      const totalSeg = ROWS * EDGE_SEGMENTS_PER_ROW;
      const tileW = boardArea.width / COLS;
      const maxDx = tileW * EDGE_JAG_FACTOR;

      for (let j = 0; j <= COLS; j++) {
        const arr = [];
        const baseX = boardArea.x + j * tileW;
        for (let k = 0; k <= totalSeg; k++) {
          const t = k / totalSeg;
          const y = boardArea.y + t * boardArea.height;

          let offset = 0;
          if (j > 0 && j < COLS) {
            offset = (Math.random() * 2 - 1) * maxDx;
          }
          const x = baseX + offset;
          arr.push({ x, y });
        }
        curves.push(arr);
      }
      return { curves, totalSeg };
    }

    function buildPiecePath(ctxLocal, piece) {
      const pts = piece.pathPoints;
      ctxLocal.beginPath();
      ctxLocal.moveTo(pts[0].x + piece.tx, pts[0].y + piece.ty);
      for (let i = 1; i < pts.length; i++) {
        ctxLocal.lineTo(pts[i].x + piece.tx, pts[i].y + piece.ty);
      }
      ctxLocal.closePath();
    }

    function createPieces() {
      pieces = [];
      piecesPlaced = 0;
      updateMoves();

      revealProgress = 0;
      revealing = false;
      revealStartTime = null;

      const tileW = boardArea.width / COLS;
      const tileH = boardArea.height / ROWS;

      const { curves } = generateVerticalCurves();
      const segPerRow = EDGE_SEGMENTS_PER_ROW;

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const k0 = r * segPerRow;
          const k1 = (r + 1) * segPerRow;

          const leftCurve = curves[c];
          const rightCurve = curves[c + 1];

          const topY = boardArea.y + r * tileH;
          const bottomY = boardArea.y + (r + 1) * tileH;

          const pts = [];

          for (let k = k0; k <= k1; k++) pts.push({ x: leftCurve[k].x, y: leftCurve[k].y });
          pts.push({ x: rightCurve[k1].x, y: bottomY });
          pts.push({ x: leftCurve[k1].x, y: bottomY });
          for (let k = k1; k >= k0; k--) pts.push({ x: rightCurve[k].x, y: rightCurve[k].y });
          pts.push({ x: leftCurve[k0].x, y: topY });

          const piece = {
            row: r,
            col: c,
            pathPoints: pts,
            tx: 0,
            ty: 0,
            placed: false,
            bbox: {
              minX: Math.min(...pts.map(p => p.x)),
              maxX: Math.max(...pts.map(p => p.x)),
              minY: Math.min(...pts.map(p => p.y)),
              maxY: Math.max(...pts.map(p => p.y)),
            }
          };

          pieces.push(piece);
        }
      }

      // 初始：碎片随机散落在同一个方框内（boardArea）
      // 关键：tx/ty 是对“绝对坐标 pathPoints”的平移，因此我们要保证平移后 bbox 仍留在 boardArea 内
      const margin = 6;
      pieces.forEach((p) => {
        const bb = p.bbox;

        const minTx = (boardArea.x - bb.minX) + margin;
        const maxTx = (boardArea.x + boardArea.width - bb.maxX) - margin;
        const minTy = (boardArea.y - bb.minY) + margin;
        const maxTy = (boardArea.y + boardArea.height - bb.maxY) - margin;

        // 如果极端情况下可移动空间为负（理论上不该），就退化为 0
        const rx = (maxTx >= minTx) ? (minTx + Math.random() * (maxTx - minTx)) : 0;
        const ry = (maxTy >= minTy) ? (minTy + Math.random() * (maxTy - minTy)) : 0;

        p.tx = rx;
        p.ty = ry;
      });

      // 打乱绘制顺序
      for (let i = pieces.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
      }
    }

    function drawPieces() {
      pieces.forEach(p => {
        ctx.save();
        buildPiecePath(ctx, p);
        ctx.clip();

        const drawX = boardArea.x + p.tx;
        const drawY = boardArea.y + p.ty;
        const w = boardArea.width;
        const h = boardArea.height;

        const baseAlpha = 0.85 + 0.15 * revealProgress;
        ctx.globalAlpha = baseAlpha;
        ctx.drawImage(imgCanvas, 0, 0, IMG_CANVAS_SIZE, IMG_CANVAS_SIZE, drawX, drawY, w, h);
        ctx.globalAlpha = 1;

        if (revealProgress < 1) {
          const overlayAlpha = (1 - revealProgress) * 0.35;
          if (overlayAlpha > 0.01) {
            ctx.globalAlpha = overlayAlpha;
            ctx.fillStyle = "#d9c3a0";
            ctx.fillRect(drawX, drawY, w, h);

            const grd = ctx.createRadialGradient(
              drawX + w / 2, drawY + h / 2, Math.min(w, h) / 5,
              drawX + w / 2, drawY + h / 2, Math.max(w, h) / 1.15
            );
            grd.addColorStop(0, "rgba(0,0,0,0)");
            grd.addColorStop(1, `rgba(0,0,0,${0.10 * overlayAlpha})`);
            ctx.globalAlpha = 1;
            ctx.fillStyle = grd;
            ctx.fillRect(drawX, drawY, w, h);
          }
        }

        ctx.globalAlpha = 1;
        ctx.restore();

        // 边框
        ctx.save();
        buildPiecePath(ctx, p);
        ctx.strokeStyle = p.placed ? "rgba(253,224,71,0.95)" : "rgba(56,189,248,0.9)";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      });
    }

    function renderAll() {
      clearCanvas();
      drawAreas();
      drawPieces();
    }

    function allPlaced() {
      return piecesPlaced === pieces.length;
    }

    function pointerToCanvasPos(e) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function buildPathForHitTest(p) {
      ctx.beginPath();
      const pts = p.pathPoints;
      ctx.moveTo(pts[0].x + p.tx, pts[0].y + p.ty);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x + p.tx, pts[i].y + p.ty);
      ctx.closePath();
    }

    function onPointerDown(e) {
      if (!running) return;
      e.preventDefault();

      const { x, y } = pointerToCanvasPos(e);

      for (let i = pieces.length - 1; i >= 0; i--) {
        const p = pieces[i];
        const bb = p.bbox;

        const minX = bb.minX + p.tx - 20;
        const maxX = bb.maxX + p.tx + 20;
        const minY = bb.minY + p.ty - 20;
        const maxY = bb.maxY + p.ty + 20;
        if (x < minX || x > maxX || y < minY || y > maxY) continue;

        buildPathForHitTest(p);
        if (!ctx.isPointInPath(x, y)) continue;

        currentPiece = p;
        dragOffsetX = x - p.tx;
        dragOffsetY = y - p.ty;

        pieces.splice(i, 1);
        pieces.push(currentPiece);

        renderAll();
        break;
      }
    }

    function onPointerMove(e) {
      if (!running || !currentPiece) return;
      e.preventDefault();

      const { x, y } = pointerToCanvasPos(e);
      let tx = x - dragOffsetX;
      let ty = y - dragOffsetY;

      // 关键修改：不让碎片拖出“同一个方框(boardArea)”
      const bb = currentPiece.bbox;
      const margin = 6;

      const minTx = (boardArea.x - bb.minX) + margin;
      const maxTx = (boardArea.x + boardArea.width - bb.maxX) - margin;
      const minTy = (boardArea.y - bb.minY) + margin;
      const maxTy = (boardArea.y + boardArea.height - bb.maxY) - margin;

      currentPiece.tx = Math.min(Math.max(tx, minTx), maxTx);
      currentPiece.ty = Math.min(Math.max(ty, minTy), maxTy);

      renderAll();
    }

    function onPointerUp(e) {
      if (!running || !currentPiece) return;
      e.preventDefault();

      const p = currentPiece;
      currentPiece = null;

      // 吸附逻辑：回到“正确位置(0,0)”就是拼对
      const dist = Math.sqrt(p.tx * p.tx + p.ty * p.ty);
      const snapThreshold = Math.min(boardArea.width / COLS, boardArea.height / ROWS) * 0.35;

      const wasPlaced = p.placed;

      if (dist < snapThreshold) {
        p.tx = 0; p.ty = 0;
        if (!wasPlaced) {
          p.placed = true;
          piecesPlaced++;
          updateMoves();
        }
      } else {
        if (wasPlaced) {
          p.placed = false;
          piecesPlaced--;
          updateMoves();
        }
      }

      renderAll();

      if (allPlaced()) {
        running = false;
        stopTimer();
        const used = parseFloat(timeEl.textContent);

        revealProgress = 0;
        revealing = true;
        revealStartTime = null;

        function animateReveal(ts) {
          if (!revealing) return;
          if (!revealStartTime) revealStartTime = ts;
          const t = (ts - revealStartTime) / REVEAL_DURATION;
          revealProgress = Math.min(1, t);
          renderAll();

          if (t < 1) {
            requestAnimationFrame(animateReveal);
          } else {
            revealing = false;
            revealProgress = 1;
            renderAll();
            setTimeout(() => {
              alert(`拼图完成！用时 ${used.toFixed(2)} 秒，共 ${piecesPlaced} 块碎片就位。\n\n谢谢你们见证我们的成长。`);
            }, 250);
          }
        }
        requestAnimationFrame(animateReveal);
      }
    }

    function attachEvents() {
      canvas.addEventListener("mousedown", onPointerDown);
      window.addEventListener("mousemove", onPointerMove);
      window.addEventListener("mouseup", onPointerUp);

      canvas.addEventListener("touchstart", onPointerDown, { passive: false });
      window.addEventListener("touchmove", onPointerMove, { passive: false });
      window.addEventListener("touchend", onPointerUp, { passive: false });
      window.addEventListener("touchcancel", onPointerUp, { passive: false });
    }

    function initAfterImageLoaded() {
      if (imageInitialized) return;
      imageInitialized = true;

      const iw = img.width, ih = img.height;
      const scale = Math.min(IMG_CANVAS_SIZE / iw, IMG_CANVAS_SIZE / ih);
      const dw = iw * scale, dh = ih * scale;
      const dx = (IMG_CANVAS_SIZE - dw) / 2;
      const dy = (IMG_CANVAS_SIZE - dh) / 2;

      imgCtx.fillStyle = "#ffffff";
      imgCtx.fillRect(0, 0, IMG_CANVAS_SIZE, IMG_CANVAS_SIZE);
      imgCtx.drawImage(img, 0, 0, iw, ih, dx, dy, dw, dh);

      layoutCanvas();
      clearCanvas();
      drawAreas();
      createPieces();
      renderAll();

      resetTimer();
      startTimer();
      attachEvents();
    }

    img.onload = initAfterImageLoaded;

    img.onerror = () => {
      layoutCanvas();
      clearCanvas();
      ctx.fillStyle = "#f97316";
      ctx.font = "14px -apple-system, system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("图片加载失败，请检查 IMAGE_SRC 路径。", canvas.width / 2, canvas.height / 2);
    };

    img.src = IMAGE_SRC;
    if (img.complete) initAfterImageLoaded();

    window.addEventListener("load", () => {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.width;

      // 这里保持原逻辑：如果已初始化则重建（自适应）
      if (imageInitialized) {
        layoutCanvas();
        createPieces();
        renderAll();
        resetTimer();
        startTimer();
      } else {
        layoutCanvas();
        clearCanvas();
        ctx.fillStyle = "#9ca3af";
        ctx.font = "14px -apple-system, system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("正在加载照片，请稍候…", canvas.width / 2, canvas.height / 2);
      }
    });

    window.addEventListener("resize", () => {
      if (!imageInitialized) return;
      layoutCanvas();
      createPieces();
      renderAll();
      resetTimer();
      startTimer();
    });
  </script>
</body>
</html>
