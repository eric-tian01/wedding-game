<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>你小时候那么可爱，我也想看看</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body{
      margin:0; padding:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","PingFang SC","Microsoft YaHei",sans-serif;
      background:#0f172a; color:#e5e7eb;
      display:flex; justify-content:center; align-items:flex-start;
      min-height:100vh;
    }
    .wrap{
      width:min(700px,96vw);
      margin:16px auto;
      display:flex; flex-direction:column; gap:10px;
    }
    h1{ margin:0; font-size:22px; text-align:center; letter-spacing:.04em; }
    .subtitle{ text-align:center; font-size:13px; opacity:.85; margin-top:4px; margin-bottom:4px; }

    .panel{
      background:radial-gradient(circle at top, rgba(30,64,175,0.35), rgba(15,23,42,0.95));
      border-radius:14px;
      padding:10px 12px 12px;
      box-shadow:0 8px 24px rgba(0,0,0,.6);
      box-sizing:border-box;
    }
    .info{ font-size:12px; opacity:.92; margin-bottom:8px; line-height:1.6; }
    .info strong{ color:#fde68a; font-weight:700; }

    /* 只保留一个正方形框 */
    .puzzle-container{
      width:100%;
      aspect-ratio:1/1;
      position:relative;
      border-radius:14px;
      overflow:hidden;
      background:#020617;
      border:2px solid rgba(148,163,184,.5);
      touch-action:none;
    }
    canvas{ width:100%; height:100%; display:block; }

    .status-row{
      display:flex;
      justify-content:space-between;
      font-size:13px;
      margin-top:8px;
      align-items:baseline;
    }
    .help{
      margin-top:6px;
      font-size:12px;
      opacity:.88;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <h1>你小时候那么可爱，我也想看看</h1>
      <div class="subtitle">大家请帮帮我！</div>
    </div>

    <div class="panel">
      <div class="info">
        说明：页面加载后拼图会自动打乱并开始计时。<br>
        <strong id="gridText"></strong>
      </div>

      <div class="puzzle-container">
        <canvas id="cv"></canvas>
      </div>

      <div class="status-row">
        <div>时间：<span id="t">0.00</span> 秒</div>
        <div>已就位碎片：<span id="done">0</span>/<span id="total">0</span></div>
      </div>

      <!-- 操作/提示 两行 -->
      <div class="help">
        <div>操作：按住碎片拖动到正确位置，接近目标会自动吸附。</div>
        <div>提示：碎片最开始堆叠在同一个框内，慢慢“抽出来”拼即可。</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== 只改这三行 =====
  const ROWS = 4;
  const COLS = 4;
  const IMAGE_URL = "./assets/images/my-photo-v1.png?v=20251214";
  // =======================

  const total = ROWS * COLS;
  document.getElementById("total").textContent = total;
  document.getElementById("gridText").textContent = `本次为 ${ROWS}×${COLS}，共 ${total} 块碎片。`;

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const tEl = document.getElementById("t");
  const doneEl = document.getElementById("done");

  let W=0, H=0;
  const img = new Image();
  img.decoding = "async";

  let pieces = []; // 每块：{r,c, x,y, tx,ty, w,h, sx,sy, sw,sh, snapped, pathLocal}
  let dragging = null;
  let dragOffX=0, dragOffY=0;
  let timer = null, startTime = 0;
  let solved = false;
  let glowStart = 0;

  // ---------- 工具：画布尺寸 ----------
  function resizeCanvas(){
    const box = cv.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    W = Math.floor(box.width);
    H = Math.floor(box.height);
    cv.width = Math.floor(W*dpr);
    cv.height = Math.floor(H*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  // ---------- 拼图边形状：为每条内部边随机生成“凸/凹/平” ----------
  // edgesH[r][c] 表示 (r,c) 与 (r+1,c) 之间的水平边（上下相邻）
  // edgesV[r][c] 表示 (r,c) 与 (r,c+1) 之间的垂直边（左右相邻）
  let edgesH = []; 
  let edgesV = [];

  function makeEdges(){
    edgesH = Array.from({length: ROWS-1}, ()=>Array.from({length: COLS}, ()=> (Math.random()<0.5 ? 1 : -1)));
    edgesV = Array.from({length: ROWS}, ()=>Array.from({length: COLS-1}, ()=> (Math.random()<0.5 ? 1 : -1)));
  }

  // ---------- 生成一块拼图的 Path2D（局部坐标：左上(0,0) 到 (w,h)） ----------
  function piecePath(r,c,w,h){
    const p = new Path2D();
    const tab = Math.min(w,h) * 0.22;      // “凸起”幅度
    const neck = Math.min(w,h) * 0.10;     // “脖子”宽度

    // 取四边类型：外边=0(直线)，内边=±1(凸/凹)
    const top    = (r===0)        ? 0 : -edgesH[r-1][c]; // 上边与上方块相反
    const bottom = (r===ROWS-1)   ? 0 :  edgesH[r][c];
    const left   = (c===0)        ? 0 : -edgesV[r][c-1];
    const right  = (c===COLS-1)   ? 0 :  edgesV[r][c];

    // 辅助：画一条带“tab”的边（从 (x1,y1) 到 (x2,y2)）
    // dir: 1 表示凸到“外侧”，-1 表示凹到“内侧”，0 表示直线
    function edge(x1,y1,x2,y2,dir,vertical){
      if (dir===0){
        p.lineTo(x2,y2);
        return;
      }
      // 分成三段：前1/3、tab、后1/3
      if (!vertical){
        // 水平边：x变化
        const dx = x2-x1;
        const s1 = x1 + dx*0.33;
        const s2 = x1 + dx*0.67;
        const mid = x1 + dx*0.50;
        const sign = dir;

        p.lineTo(s1, y1);

        // tab（贝塞尔）
        p.bezierCurveTo(
          s1 + neck, y1,
          mid - neck, y1 + sign*tab,
          mid, y1 + sign*tab
        );
        p.bezierCurveTo(
          mid + neck, y1 + sign*tab,
          s2 - neck, y1,
          s2, y1
        );

        p.lineTo(x2,y2);
      } else {
        // 垂直边：y变化
        const dy = y2-y1;
        const s1 = y1 + dy*0.33;
        const s2 = y1 + dy*0.67;
        const mid = y1 + dy*0.50;
        const sign = dir;

        p.lineTo(x1, s1);

        p.bezierCurveTo(
          x1, s1 + neck,
          x1 + sign*tab, mid - neck,
          x1 + sign*tab, mid
        );
        p.bezierCurveTo(
          x1 + sign*tab, mid + neck,
          x1, s2 - neck,
          x1, s2
        );

        p.lineTo(x2,y2);
      }
    }

    // 从左上开始顺时针
    p.moveTo(0,0);
    // top: (0,0) -> (w,0)
    edge(0,0,w,0, top, false);
    // right: (w,0) -> (w,h)
    edge(w,0,w,h, right, true);
    // bottom: (w,h) -> (0,h)  注意反向水平
    edge(w,h,0,h, -bottom, false);
    // left: (0,h) -> (0,0)  注意反向垂直
    edge(0,h,0,0, -left, true);

    p.closePath();
    return p;
  }

  // ---------- cover 裁切：把图像映射到正方形 ----------
  function computeCover(){
    const imgAR = img.width / img.height;
    const boxAR = W / H;
    let drawW, drawH, offsetX, offsetY;

    if (imgAR > boxAR){
      drawH = img.height;
      drawW = img.height * boxAR;
      offsetX = (img.width - drawW)/2;
      offsetY = 0;
    } else {
      drawW = img.width;
      drawH = img.width / boxAR;
      offsetX = 0;
      offsetY = (img.height - drawH)/2;
    }
    return {drawW, drawH, offsetX, offsetY};
  }

  // ---------- 构建碎片 ----------
  function buildPieces(){
    solved = false;
    glowStart = 0;

    pieces = [];
    const tileW = W / COLS;
    const tileH = H / ROWS;

    const {drawW, drawH, offsetX, offsetY} = computeCover();
    const sw = drawW / COLS;
    const sh = drawH / ROWS;

    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const tx = c*tileW;
        const ty = r*tileH;

        // 初始：堆叠在中心
        const jitter = 18;
        const x0 = (W - tileW)/2 + (Math.random()*2-1)*jitter;
        const y0 = (H - tileH)/2 + (Math.random()*2-1)*jitter;

        pieces.push({
          r,c,
          x:x0, y:y0,
          tx,ty,
          w:tileW, h:tileH,
          sx: offsetX + c*sw,
          sy: offsetY + r*sh,
          sw, sh,
          snapped:false,
          pathLocal: piecePath(r,c,tileW,tileH),
        });
      }
    }
    // 打乱绘制层级
    pieces.sort(()=>Math.random()-0.5);
    doneEl.textContent = "0";
  }

  // ---------- 命中测试：用 Path2D + isPointInPath（从上往下） ----------
  function hitTest(mx,my){
    for (let i=pieces.length-1; i>=0; i--){
      const p = pieces[i];
      // solved 之后才全锁死；否则即使 snapped 也允许拖
      if (solved) continue;

      ctx.save();
      ctx.translate(p.x, p.y);
      const ok = ctx.isPointInPath(p.pathLocal, mx - p.x, my - p.y);
      ctx.restore();
      if (ok) return p;
    }
    return null;
  }

  // ---------- 吸附：只“计为就位”，不锁死；允许再拖走 ----------
  function updateSnapped(p){
    const dx = p.x - p.tx;
    const dy = p.y - p.ty;
    const dist = Math.hypot(dx,dy);
    const thresh = Math.min(p.w,p.h) * 0.12;

    // 只要足够接近，就把它“吸”到目标，但仍可拖动
    if (dist < thresh){
      p.x = p.tx;
      p.y = p.ty;
      p.snapped = true;
    } else {
      p.snapped = false;
    }
  }

  function updateDoneAndSolved(){
    const done = pieces.filter(p=>p.snapped).length;
    doneEl.textContent = String(done);
    if (done === total && !solved){
      solved = true;
      stopTimer();
      glowStart = performance.now();
    }
  }

  // ---------- 计时 ----------
  function startTimer(){
    if (timer) return;
    startTime = performance.now();
    timer = setInterval(()=>{
      tEl.textContent = ((performance.now()-startTime)/1000).toFixed(2);
    }, 60);
  }
  function stopTimer(){
    if (!timer) return;
    clearInterval(timer);
    timer = null;
  }

  // ---------- 绘制 ----------
  function draw(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#020617";
    ctx.fillRect(0,0,W,H);

    if (!img.complete){
      ctx.fillStyle = "rgba(229,231,235,.7)";
      ctx.font = "14px system-ui, -apple-system, Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText("正在加载照片，请稍候…", W/2, H/2);
      return;
    }

    // 完成特效：全亮 + 发光（短暂）
    const now = performance.now();
    let glow = 0;
    if (solved && glowStart){
      glow = Math.min(1, (now - glowStart)/700); // 0~1
    }

    const list = dragging ? pieces.filter(p=>p!==dragging).concat([dragging]) : pieces;

    for (const p of list){
      ctx.save();
      ctx.translate(p.x, p.y);

      // clip 出不规则碎片形状
      ctx.clip(p.pathLocal);

      // 视觉逻辑：
      // - 未完成：整体灰；snapped 的块略微减少灰度（但仍偏灰）
      // - 完成：逐渐恢复彩色 + 发光
      if (!solved){
        const g = p.snapped ? 0.55 : 1.0;  // snapped 也不“亮起来”，只是略微提示
        ctx.filter = `grayscale(${g}) contrast(1.05)`;
      } else {
        // 从灰到彩
        const g = Math.max(0, 1 - glow);
        ctx.filter = `grayscale(${g})`;
        // glow 阴影
        ctx.shadowColor = `rgba(255,255,255,${0.35*glow})`;
        ctx.shadowBlur = 28 * glow;
      }

      // 画该块对应的图像区域
      ctx.drawImage(
        img,
        p.sx, p.sy, p.sw, p.sh,
        0, 0, p.w, p.h
      );

      ctx.restore();

      // 轮廓线（不泄题，只做质感）
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.globalAlpha = solved ? 0.18 : 0.22;
      ctx.strokeStyle = "#94a3b8";
      ctx.lineWidth = 1;
      ctx.stroke(p.pathLocal);
      ctx.restore();
    }

    // 完成后持续一小段动画更顺滑
    if (solved && glow < 1){
      requestAnimationFrame(draw);
    }
  }

  // ---------- 事件 ----------
  function pointerPos(e){
    const rect = cv.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  cv.addEventListener("pointerdown", (e)=>{
    const {x,y} = pointerPos(e);
    const p = hitTest(x,y);
    if (!p) return;

    startTimer();
    dragging = p;

    // 提到最上层
    pieces = pieces.filter(q=>q!==p);
    pieces.push(p);

    dragOffX = x - p.x;
    dragOffY = y - p.y;
    cv.setPointerCapture(e.pointerId);
    draw();
  });

  cv.addEventListener("pointermove", (e)=>{
    if (!dragging || solved) return;
    const {x,y} = pointerPos(e);
    dragging.x = x - dragOffX;
    dragging.y = y - dragOffY;
    // 拖动中，先认为没就位（避免“吸住就永远算对”）
    dragging.snapped = false;
    draw();
  });

  cv.addEventListener("pointerup", ()=>{
    if (!dragging) return;
    updateSnapped(dragging);
    updateDoneAndSolved();
    dragging = null;
    draw();
  });

  window.addEventListener("resize", ()=>{
    resizeCanvas();
    if (img.complete){
      // 尺寸变化时重新开局更稳（否则 path、坐标都会错）
      makeEdges();
      buildPieces();
      draw();
    }
  });

  // ---------- 加载 ----------
  img.onload = ()=>{
    resizeCanvas();
    makeEdges();
    buildPieces();
    draw();
  };

  img.onerror = ()=>{
    resizeCanvas();
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "rgba(229,231,235,.85)";
    ctx.font = "14px system-ui, -apple-system, Segoe UI";
    ctx.textAlign = "center";
    const realUrl = new URL(IMAGE_URL, location.href).href;
    console.error("IMAGE LOAD FAIL:", realUrl);
    ctx.fillText("图片加载失败", W/2, H/2 - 10);
    ctx.fillText(realUrl, W/2, H/2 + 12);
  };

  img.src = IMAGE_URL;
})();
</script>

</body>
</html>

